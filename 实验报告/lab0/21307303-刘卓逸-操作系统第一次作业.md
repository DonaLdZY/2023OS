操作系统第一次作业
刘卓逸 21307303

## 任务描述

针对动态获得锁情况下的死锁问题，提出解决方案并介绍解决思路，也可以结合
一段死锁代码或伪代码来回答

## 问题

动态获得锁情况下的死锁问题是指当多个线程需要相同的一些锁，但是按照不同的顺序加锁，导致互相等待而无法继续执行的情况。如以下伪代码，线程1在等线程2手上的lock2,线程2在等线程1的lock1，这便会导致死锁。

```
线程1:
    申请获取lock1
    获取成功后线程休眠1秒
    申请获得lock2


线程2：
    申请获取lock2
    获取成功后线程休眠1秒
    申请获得lock1
    结束

Main:
    启动线程1
    启动线程2
```

## 解决方案

给每个动态锁进行编号，每个线程需要申请某个动态锁时，必须按照从小到大的顺序去申请锁，这样锁就可以装在线程对应的一个栈内，这个栈必须是单调的。如果是运行一半去申请某个动态锁，必须先把原本持有的编号大于准备申请的动态锁的动态锁释放，在申请完当前的动态锁后再把编号大的动态锁申请回来。

```c++
class PCB{
    ......
    stack<lock> locks;
    void apply_lock(lock Xlock){
        //把编号大的锁先释放掉
        while (locks.top().id > Xlock.id ){ 
            temp_stack.push( locks.top() ); //记录释放掉的锁
            release( locks.top() );
            locks.pop();
        }
        //申请当前锁
        apply( Xlock ); 
        //把之前释放的锁申请回来
        while ( ! temp_stack.empty() ){
            apply( temp_stack.top() );
            temp_stack.pop();
        }
    }
 }
```

### 方案合理性论证

设有若干线程，死锁的情况就是，以线程为点，以线程间的锁等待关系即(申请lockX的线程 -> 持有lockX的线程)的方式建编号为X的边，建立有向图，该有向图出现环。

对于该有向图的每一个死锁环，必然会有一条边的编号(即代表的锁的编号)最小，设该边为(A -> B)，即B持有编号最小的锁X，那该环上肯定有边指向A，设为(C -> A)编号为Y，由于X是编号最小的所以有Y>X，而线程A为了能去申请X，一定要先把Y吐出来，这样(C -> A)这条边就不存在了，死锁环就会被打破。

所以该解决方案理论上是可行的。但每次申请锁或中途释放锁都会花费O(n)次释放与申请锁。


